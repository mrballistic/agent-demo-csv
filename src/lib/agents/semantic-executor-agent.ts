/**
 * Semantic Query Execution Agent
 * Executes semantic query plans generated by QueryPlannerAgent to process
 * structured data queries without requiring LLM calls, optimizing for performance and cost.
 */

import { BaseAgent, createExecutionContext } from './base';
import {
  AgentType,
  DataProfile,
  ExecutionPlan,
  PlanStep,
  QueryIntent,
  FilterCondition,
} from './types';

export interface SemanticExecutorInput {
  queryIntent: QueryIntent;
  profile: DataProfile;
  executionPlan: ExecutionPlan;
}

export interface SemanticExecutorResult {
  data: Record<string, any>[];
  metadata: {
    totalRows: number;
    processedRows: number;
    executionTime: number;
    stepsExecuted: number;
    cacheUsed: boolean;
  };
  insights: {
    keyFindings: string[];
    trends?: Array<{
      metric: string;
      direction: 'increasing' | 'decreasing' | 'stable';
      changePercent: number;
    }>;
    aggregations?: Record<string, number>;
  };
}

/**
 * Semantic Query Execution Agent
 *
 * Processes execution plans to perform data analysis operations locally
 * without requiring LLM API calls, providing significant cost savings
 * and performance improvements for structured queries.
 */
export class SemanticExecutorAgent extends BaseAgent<
  SemanticExecutorInput,
  SemanticExecutorResult
> {
  readonly type = AgentType.SEMANTIC_EXECUTOR;
  readonly name = 'SemanticExecutorAgent';

  constructor() {
    super();
    console.log('SemanticExecutorAgent initialized');
  }

  validateInput(input: SemanticExecutorInput): boolean {
    if (!input.queryIntent) {
      throw new Error('QueryIntent is required');
    }

    if (!input.profile || !input.profile.sampleData) {
      throw new Error('Valid DataProfile with sample data is required');
    }

    if (!input.executionPlan || !input.executionPlan.steps.length) {
      throw new Error('ExecutionPlan with steps is required');
    }

    return true;
  }

  protected async executeInternal(
    input: SemanticExecutorInput,
    context: any
  ): Promise<SemanticExecutorResult> {
    const startTime = Date.now();
    console.log(
      `Executing semantic query plan with ${input.executionPlan.steps.length} steps`
    );

    // Start with the sample data from the profile
    let currentData = [...input.profile.sampleData];
    let stepsExecuted = 0;
    const cacheUsed = false; // TODO: Implement caching

    try {
      // Execute plan steps in dependency order
      const sortedSteps = this.sortStepsByDependencies(
        input.executionPlan.steps
      );

      for (const step of sortedSteps) {
        console.log(
          `Executing step ${step.id}: ${step.type} - ${step.operation}`
        );
        currentData = await this.executeStep(
          step,
          currentData,
          input.profile,
          input.queryIntent
        );
        stepsExecuted++;

        // Check for cancellation
        if (context.signal?.aborted) {
          throw new Error('Execution was cancelled');
        }
      }

      // Generate insights from the processed data
      const insights = this.generateInsights(
        currentData,
        input.queryIntent,
        input.profile
      );

      const executionTime = Date.now() - startTime;
      console.log(`Semantic execution completed in ${executionTime}ms`);

      return {
        data: currentData,
        metadata: {
          totalRows: input.profile.metadata.rowCount,
          processedRows: currentData.length,
          executionTime,
          stepsExecuted,
          cacheUsed,
        },
        insights,
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;
      console.error('Semantic execution failed:', error);

      throw new Error(
        `Semantic execution failed after ${executionTime}ms: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Sort execution steps by their dependencies
   */
  private sortStepsByDependencies(steps: PlanStep[]): PlanStep[] {
    const sorted: PlanStep[] = [];
    const visited = new Set<string>();
    const visiting = new Set<string>();

    const stepMap = new Map(steps.map(step => [step.id, step]));

    const visit = (stepId: string) => {
      if (visiting.has(stepId)) {
        throw new Error(
          `Circular dependency detected in execution plan at step: ${stepId}`
        );
      }
      if (visited.has(stepId)) {
        return;
      }

      const step = stepMap.get(stepId);
      if (!step) {
        throw new Error(`Step not found: ${stepId}`);
      }

      visiting.add(stepId);

      // Visit dependencies first
      for (const dependencyId of step.dependsOn) {
        if (dependencyId && stepMap.has(dependencyId)) {
          visit(dependencyId);
        }
      }

      visiting.delete(stepId);
      visited.add(stepId);
      sorted.push(step);
    };

    // Visit all steps
    for (const step of steps) {
      if (!visited.has(step.id)) {
        visit(step.id);
      }
    }

    return sorted;
  }

  /**
   * Execute a single plan step
   */
  private async executeStep(
    step: PlanStep,
    data: Record<string, any>[],
    profile: DataProfile,
    queryIntent: QueryIntent
  ): Promise<Record<string, any>[]> {
    switch (step.type) {
      case 'load':
        return this.executeLoadStep(step, data, profile);
      case 'filter':
        return this.executeFilterStep(step, data, profile);
      case 'aggregate':
        return this.executeAggregateStep(step, data, profile);
      case 'sort':
        return this.executeSortStep(step, data, profile);
      case 'limit':
        return this.executeLimitStep(step, data, profile);
      case 'transform':
        return this.executeTransformStep(step, data, profile);
      default:
        console.warn(`Unknown step type: ${step.type}, skipping`);
        return data;
    }
  }

  /**
   * Execute load step - prepare data for processing
   */
  private executeLoadStep(
    step: PlanStep,
    data: Record<string, any>[],
    profile: DataProfile
  ): Record<string, any>[] {
    // For semantic execution, we work with the sample data
    // In a full implementation, this would load the actual dataset
    console.log(`Loading data: ${data.length} rows available`);
    return data;
  }

  /**
   * Execute filter step - apply filtering conditions
   */
  private executeFilterStep(
    step: PlanStep,
    data: Record<string, any>[],
    profile: DataProfile
  ): Record<string, any>[] {
    const { filters } = step.params;

    if (!filters || !Array.isArray(filters)) {
      return data;
    }

    return data.filter(row => {
      return filters.every((filter: FilterCondition) => {
        const value = row[filter.column];
        const filterValue = filter.value;

        switch (filter.operator) {
          case 'eq':
            return value == filterValue;
          case 'ne':
            return value != filterValue;
          case 'gt':
            return Number(value) > Number(filterValue);
          case 'lt':
            return Number(value) < Number(filterValue);
          case 'gte':
            return Number(value) >= Number(filterValue);
          case 'lte':
            return Number(value) <= Number(filterValue);
          case 'contains':
            return String(value)
              .toLowerCase()
              .includes(String(filterValue).toLowerCase());
          case 'starts_with':
            return String(value)
              .toLowerCase()
              .startsWith(String(filterValue).toLowerCase());
          case 'ends_with':
            return String(value)
              .toLowerCase()
              .endsWith(String(filterValue).toLowerCase());
          default:
            return true;
        }
      });
    });
  }

  /**
   * Execute aggregate step - perform aggregations on data
   */
  private executeAggregateStep(
    step: PlanStep,
    data: Record<string, any>[],
    profile: DataProfile
  ): Record<string, any>[] {
    const { measures, dimensions, aggregationType } = step.params;

    if (!measures || measures.length === 0) {
      return data;
    }

    // Group data by dimensions
    const grouped = this.groupByDimensions(data, dimensions || []);

    // Apply aggregations to each group
    const results: Record<string, any>[] = [];

    for (const [groupKey, groupData] of grouped.entries()) {
      const result: Record<string, any> = {};

      // Add dimension values to result
      if (dimensions && dimensions.length > 0) {
        const groupValues = groupKey.split('|');
        dimensions.forEach((dim: string, index: number) => {
          result[dim] = groupValues[index] || null;
        });
      }

      // Calculate aggregations for each measure
      for (const measure of measures) {
        const values = groupData
          .map(row => Number(row[measure]))
          .filter(val => !isNaN(val));

        if (values.length === 0) {
          result[measure] = null;
          continue;
        }

        switch (aggregationType) {
          case 'sum':
            result[measure] = values.reduce((sum, val) => sum + val, 0);
            break;
          case 'avg':
            result[measure] =
              values.reduce((sum, val) => sum + val, 0) / values.length;
            break;
          case 'count':
            result[measure] = values.length;
            break;
          case 'min':
            result[measure] = Math.min(...values);
            break;
          case 'max':
            result[measure] = Math.max(...values);
            break;
          default:
            result[measure] = values.length; // Default to count
        }
      }

      results.push(result);
    }

    return results;
  }

  /**
   * Group data by dimensions
   */
  private groupByDimensions(
    data: Record<string, any>[],
    dimensions: string[]
  ): Map<string, Record<string, any>[]> {
    const groups = new Map<string, Record<string, any>[]>();

    for (const row of data) {
      // Create group key from dimension values
      const groupKey =
        dimensions.length > 0
          ? dimensions.map(dim => String(row[dim] || '')).join('|')
          : 'all';

      if (!groups.has(groupKey)) {
        groups.set(groupKey, []);
      }
      groups.get(groupKey)!.push(row);
    }

    return groups;
  }

  /**
   * Execute sort step - sort data by specified columns
   */
  private executeSortStep(
    step: PlanStep,
    data: Record<string, any>[],
    profile: DataProfile
  ): Record<string, any>[] {
    const { columns, direction } = step.params;

    if (!columns || columns.length === 0) {
      return data;
    }

    return [...data].sort((a, b) => {
      for (const column of columns) {
        const aVal = a[column];
        const bVal = b[column];

        let comparison = 0;

        // Handle different data types
        if (typeof aVal === 'number' && typeof bVal === 'number') {
          comparison = aVal - bVal;
        } else if (aVal instanceof Date && bVal instanceof Date) {
          comparison = aVal.getTime() - bVal.getTime();
        } else {
          comparison = String(aVal).localeCompare(String(bVal));
        }

        if (comparison !== 0) {
          return direction === 'desc' ? -comparison : comparison;
        }
      }
      return 0;
    });
  }

  /**
   * Execute limit step - limit number of results
   */
  private executeLimitStep(
    step: PlanStep,
    data: Record<string, any>[],
    profile: DataProfile
  ): Record<string, any>[] {
    const { limit } = step.params;

    if (!limit || limit <= 0) {
      return data;
    }

    return data.slice(0, limit);
  }

  /**
   * Execute transform step - apply data transformations
   */
  private executeTransformStep(
    step: PlanStep,
    data: Record<string, any>[],
    profile: DataProfile
  ): Record<string, any>[] {
    // TODO: Implement data transformations based on step parameters
    console.log(`Transform step not yet implemented: ${step.operation}`);
    return data;
  }

  /**
   * Generate insights from processed data
   */
  private generateInsights(
    data: Record<string, any>[],
    queryIntent: QueryIntent,
    profile: DataProfile
  ): SemanticExecutorResult['insights'] {
    const insights: SemanticExecutorResult['insights'] = {
      keyFindings: [],
    };

    // Generate basic findings
    insights.keyFindings.push(`Processed ${data.length} rows of data`);

    // Generate aggregation insights
    if (queryIntent.entities.measures.length > 0) {
      const aggregations: Record<string, number> = {};

      for (const measure of queryIntent.entities.measures) {
        const values = data
          .map(row => Number(row[measure]))
          .filter(val => !isNaN(val));

        if (values.length > 0) {
          aggregations[`${measure}_sum`] = values.reduce(
            (sum, val) => sum + val,
            0
          );
          aggregations[`${measure}_avg`] =
            (aggregations[`${measure}_sum`] ?? 0) / values.length;
          aggregations[`${measure}_min`] = Math.min(...values);
          aggregations[`${measure}_max`] = Math.max(...values);
        }
      }

      insights.aggregations = aggregations;

      if (Object.keys(aggregations).length > 0) {
        insights.keyFindings.push(
          `Calculated aggregations for ${queryIntent.entities.measures.length} measures`
        );
      }
    }

    // Generate trend insights for trend queries
    if (queryIntent.type === 'trend' && data.length > 1) {
      const trends: SemanticExecutorResult['insights']['trends'] = [];

      for (const measure of queryIntent.entities.measures) {
        const values = data
          .map(row => Number(row[measure]))
          .filter(val => !isNaN(val));

        if (values.length >= 2) {
          const first = values[0]!;
          const last = values[values.length - 1]!;
          const changePercent =
            first !== 0 ? ((last - first) / first) * 100 : 0;

          let direction: 'increasing' | 'decreasing' | 'stable';
          if (changePercent > 5) {
            direction = 'increasing';
          } else if (changePercent < -5) {
            direction = 'decreasing';
          } else {
            direction = 'stable';
          }

          trends.push({
            metric: measure,
            direction,
            changePercent: Math.round(changePercent * 100) / 100,
          });
        }
      }

      if (trends.length > 0) {
        insights.trends = trends;
        insights.keyFindings.push(
          `Identified trends for ${trends.length} metrics`
        );
      }
    }

    return insights;
  }
}
